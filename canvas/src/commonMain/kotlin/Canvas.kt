package com.juul.krayon.canvas

public interface Canvas<P : Path> {

    /**
     * Draw an arc that fits in the oval defined by the rectangle [left], [top], [right], and [bottom], from
     * [startAngle] (in degrees, with 0 at the right) to [startAngle] + [sweepAngle].
     *
     * If [useCenter] is true, the center of the oval is included in the arc, producing a wedge shape.
     */
    public fun drawArc(
        left: Float,
        top: Float,
        right: Float,
        bottom: Float,
        startAngle: Float,
        sweepAngle: Float,
        useCenter: Boolean,
        paint: Paint
    )

    /** Draw a circle at [centerX], [centerY] with size defined by its [radius]. */
    public fun drawCircle(centerX: Float, centerY: Float, radius: Float, paint: Paint)

    /** Draw a line from [startX], [startY] to [endX], [endY]. */
    public fun drawLine(startX: Float, startY: Float, endX: Float, endY: Float, paint: Paint.Stroke)

    /** Draw an oval defined by the rectangle [left], [top], [right], and [bottom] */
    public fun drawOval(left: Float, top: Float, right: Float, bottom: Float, paint: Paint)

    /** Create a path understood by this canvas. The returned path should NOT have a reference to the canvas. */
    public fun buildPath(actions: Path.Builder<*>.() -> Unit): P

    /** Draws a path returned by [buildPath]. */
    public fun drawPath(path: P, paint: Paint)

    /** Draws a string of [text] at [x], [y]. Exact horizontal behavior is controlled by the [paint]'s [alignment][Paint.Text.Alignment]. */
    public fun drawText(text: CharSequence, x: Float, y: Float, paint: Paint.Text)

    /**
     * Pushes a [clip] to the canvas. Remove it with [pop].
     *
     * If this is a [Clip.Path], it must be a path of the same type generated by [buildPath].
     */
    public fun pushClip(clip: Clip)

    /** Pushes a [transform] to the canvas. Remove it with [pop]. */
    public fun pushTransform(transform: Transform)

    /** Removes the last [pushClip] or [pushTransform] operation. */
    public fun pop()
}

/** Invokes [actions] inside of a [Canvas.pushClip]/[Canvas.pop] pair. */
public inline fun <P : Path> Canvas<P>.withClip(
    clip: Clip,
    actions: Canvas<P>.() -> Unit
) {
    pushClip(clip)
    try {
        actions.invoke(this)
    } finally {
        pop()
    }
}

/** Invokes [actions] inside of a [Canvas.pushTransform]/[Canvas.pop] pair. */
public inline fun <P : Path> Canvas<P>.withTransform(
    transform: Transform,
    actions: Canvas<P>.() -> Unit
) {
    pushTransform(transform)
    try {
        actions.invoke(this)
    } finally {
        pop()
    }
}
