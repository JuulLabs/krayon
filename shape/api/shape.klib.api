// Klib ABI Dump
// Targets: [iosArm64, iosSimulatorArm64, iosX64, js, macosArm64, macosX64]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <com.juul.krayon:shape>
abstract interface <#A: kotlin/Any> com.juul.krayon.shape/Shape { // com.juul.krayon.shape/Shape|null[0]
    abstract fun render(kotlin.collections/List<#A?>): com.juul.krayon.kanvas/Path // com.juul.krayon.shape/Shape.render|render(kotlin.collections.List<1:0?>){}[0]
}

abstract interface com.juul.krayon.shape.curve/Curve { // com.juul.krayon.shape.curve/Curve|null[0]
    abstract fun endArea(com.juul.krayon.kanvas/PathBuilder<*>) // com.juul.krayon.shape.curve/Curve.endArea|endArea(com.juul.krayon.kanvas.PathBuilder<*>){}[0]
    abstract fun endLine(com.juul.krayon.kanvas/PathBuilder<*>) // com.juul.krayon.shape.curve/Curve.endLine|endLine(com.juul.krayon.kanvas.PathBuilder<*>){}[0]
    abstract fun point(com.juul.krayon.kanvas/PathBuilder<*>, kotlin/Float, kotlin/Float) // com.juul.krayon.shape.curve/Curve.point|point(com.juul.krayon.kanvas.PathBuilder<*>;kotlin.Float;kotlin.Float){}[0]
    abstract fun startArea(com.juul.krayon.kanvas/PathBuilder<*>) // com.juul.krayon.shape.curve/Curve.startArea|startArea(com.juul.krayon.kanvas.PathBuilder<*>){}[0]
    abstract fun startLine(com.juul.krayon.kanvas/PathBuilder<*>) // com.juul.krayon.shape.curve/Curve.startLine|startLine(com.juul.krayon.kanvas.PathBuilder<*>){}[0]
}

final class <#A: kotlin/Any> com.juul.krayon.shape/Arguments { // com.juul.krayon.shape/Arguments|null[0]
    final var data // com.juul.krayon.shape/Arguments.data|{}data[0]
        final fun <get-data>(): kotlin.collections/List<#A?> // com.juul.krayon.shape/Arguments.data.<get-data>|<get-data>(){}[0]
    final var datum // com.juul.krayon.shape/Arguments.datum|{}datum[0]
        final fun <get-datum>(): #A // com.juul.krayon.shape/Arguments.datum.<get-datum>|<get-datum>(){}[0]
    final var index // com.juul.krayon.shape/Arguments.index|{}index[0]
        final fun <get-index>(): kotlin/Int // com.juul.krayon.shape/Arguments.index.<get-index>|<get-index>(){}[0]

    final fun component1(): #A // com.juul.krayon.shape/Arguments.component1|component1(){}[0]
    final fun component2(): kotlin/Int // com.juul.krayon.shape/Arguments.component2|component2(){}[0]
    final fun component3(): kotlin.collections/List<#A?> // com.juul.krayon.shape/Arguments.component3|component3(){}[0]
}

final class <#A: kotlin/Any> com.juul.krayon.shape/Line : com.juul.krayon.shape/Shape<#A> { // com.juul.krayon.shape/Line|null[0]
    final fun curve(com.juul.krayon.shape.curve/Curve): com.juul.krayon.shape/Line<#A> // com.juul.krayon.shape/Line.curve|curve(com.juul.krayon.shape.curve.Curve){}[0]
    final fun defined(kotlin/Function1<com.juul.krayon.shape/Arguments<#A>, kotlin/Boolean>): com.juul.krayon.shape/Line<#A> // com.juul.krayon.shape/Line.defined|defined(kotlin.Function1<com.juul.krayon.shape.Arguments<1:0>,kotlin.Boolean>){}[0]
    final fun render(kotlin.collections/List<#A?>): com.juul.krayon.kanvas/Path // com.juul.krayon.shape/Line.render|render(kotlin.collections.List<1:0?>){}[0]
    final fun x(kotlin/Float): com.juul.krayon.shape/Line<#A> // com.juul.krayon.shape/Line.x|x(kotlin.Float){}[0]
    final fun x(kotlin/Function1<com.juul.krayon.shape/Arguments<#A>, kotlin/Float>): com.juul.krayon.shape/Line<#A> // com.juul.krayon.shape/Line.x|x(kotlin.Function1<com.juul.krayon.shape.Arguments<1:0>,kotlin.Float>){}[0]
    final fun y(kotlin/Float): com.juul.krayon.shape/Line<#A> // com.juul.krayon.shape/Line.y|y(kotlin.Float){}[0]
    final fun y(kotlin/Function1<com.juul.krayon.shape/Arguments<#A>, kotlin/Float>): com.juul.krayon.shape/Line<#A> // com.juul.krayon.shape/Line.y|y(kotlin.Function1<com.juul.krayon.shape.Arguments<1:0>,kotlin.Float>){}[0]
}

final class <#A: kotlin/Any?> com.juul.krayon.shape/Pie { // com.juul.krayon.shape/Pie|null[0]
    final var endAngle // com.juul.krayon.shape/Pie.endAngle|{}endAngle[0]
        final fun <get-endAngle>(): kotlin/Float // com.juul.krayon.shape/Pie.endAngle.<get-endAngle>|<get-endAngle>(){}[0]
    final var padAngle // com.juul.krayon.shape/Pie.padAngle|{}padAngle[0]
        final fun <get-padAngle>(): kotlin/Float // com.juul.krayon.shape/Pie.padAngle.<get-padAngle>|<get-padAngle>(){}[0]
    final var startAngle // com.juul.krayon.shape/Pie.startAngle|{}startAngle[0]
        final fun <get-startAngle>(): kotlin/Float // com.juul.krayon.shape/Pie.startAngle.<get-startAngle>|<get-startAngle>(){}[0]

    final fun <#A1: kotlin/Any?> value(kotlin/Function1<#A1, kotlin/Float>): com.juul.krayon.shape/Pie<#A1> // com.juul.krayon.shape/Pie.value|value(kotlin.Function1<0:0,kotlin.Float>){0ยง<kotlin.Any?>}[0]
    final fun endAngle(kotlin/Float): com.juul.krayon.shape/Pie<#A> // com.juul.krayon.shape/Pie.endAngle|endAngle(kotlin.Float){}[0]
    final fun invoke(kotlin.collections/List<#A>): kotlin.collections/List<com.juul.krayon.shape/Slice<#A>> // com.juul.krayon.shape/Pie.invoke|invoke(kotlin.collections.List<1:0>){}[0]
    final fun invoke(kotlin/Array<out #A>...): kotlin.collections/List<com.juul.krayon.shape/Slice<#A>> // com.juul.krayon.shape/Pie.invoke|invoke(kotlin.Array<out|1:0>...){}[0]
    final fun padAngle(kotlin/Float): com.juul.krayon.shape/Pie<#A> // com.juul.krayon.shape/Pie.padAngle|padAngle(kotlin.Float){}[0]
    final fun startAngle(kotlin/Float): com.juul.krayon.shape/Pie<#A> // com.juul.krayon.shape/Pie.startAngle|startAngle(kotlin.Float){}[0]
}

final class <#A: kotlin/Any?> com.juul.krayon.shape/Slice { // com.juul.krayon.shape/Slice|null[0]
    constructor <init>(#A, kotlin/Float, kotlin/Int, kotlin/Float, kotlin/Float, kotlin/Float) // com.juul.krayon.shape/Slice.<init>|<init>(1:0;kotlin.Float;kotlin.Int;kotlin.Float;kotlin.Float;kotlin.Float){}[0]

    final val data // com.juul.krayon.shape/Slice.data|{}data[0]
        final fun <get-data>(): #A // com.juul.krayon.shape/Slice.data.<get-data>|<get-data>(){}[0]
    final val endAngle // com.juul.krayon.shape/Slice.endAngle|{}endAngle[0]
        final fun <get-endAngle>(): kotlin/Float // com.juul.krayon.shape/Slice.endAngle.<get-endAngle>|<get-endAngle>(){}[0]
    final val index // com.juul.krayon.shape/Slice.index|{}index[0]
        final fun <get-index>(): kotlin/Int // com.juul.krayon.shape/Slice.index.<get-index>|<get-index>(){}[0]
    final val padAngle // com.juul.krayon.shape/Slice.padAngle|{}padAngle[0]
        final fun <get-padAngle>(): kotlin/Float // com.juul.krayon.shape/Slice.padAngle.<get-padAngle>|<get-padAngle>(){}[0]
    final val startAngle // com.juul.krayon.shape/Slice.startAngle|{}startAngle[0]
        final fun <get-startAngle>(): kotlin/Float // com.juul.krayon.shape/Slice.startAngle.<get-startAngle>|<get-startAngle>(){}[0]
    final val value // com.juul.krayon.shape/Slice.value|{}value[0]
        final fun <get-value>(): kotlin/Float // com.juul.krayon.shape/Slice.value.<get-value>|<get-value>(){}[0]

    final fun component1(): #A // com.juul.krayon.shape/Slice.component1|component1(){}[0]
    final fun component2(): kotlin/Float // com.juul.krayon.shape/Slice.component2|component2(){}[0]
    final fun component3(): kotlin/Int // com.juul.krayon.shape/Slice.component3|component3(){}[0]
    final fun component4(): kotlin/Float // com.juul.krayon.shape/Slice.component4|component4(){}[0]
    final fun component5(): kotlin/Float // com.juul.krayon.shape/Slice.component5|component5(){}[0]
    final fun component6(): kotlin/Float // com.juul.krayon.shape/Slice.component6|component6(){}[0]
    final fun copy(#A = ..., kotlin/Float = ..., kotlin/Int = ..., kotlin/Float = ..., kotlin/Float = ..., kotlin/Float = ...): com.juul.krayon.shape/Slice<#A> // com.juul.krayon.shape/Slice.copy|copy(1:0;kotlin.Float;kotlin.Int;kotlin.Float;kotlin.Float;kotlin.Float){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // com.juul.krayon.shape/Slice.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // com.juul.krayon.shape/Slice.hashCode|hashCode(){}[0]
    final fun toString(): kotlin/String // com.juul.krayon.shape/Slice.toString|toString(){}[0]
}

final class com.juul.krayon.shape/Arc { // com.juul.krayon.shape/Arc|null[0]
    final var cornerRadius // com.juul.krayon.shape/Arc.cornerRadius|{}cornerRadius[0]
        final fun <get-cornerRadius>(): kotlin/Float // com.juul.krayon.shape/Arc.cornerRadius.<get-cornerRadius>|<get-cornerRadius>(){}[0]
    final var innerRadius // com.juul.krayon.shape/Arc.innerRadius|{}innerRadius[0]
        final fun <get-innerRadius>(): kotlin/Float // com.juul.krayon.shape/Arc.innerRadius.<get-innerRadius>|<get-innerRadius>(){}[0]
    final var outerRadius // com.juul.krayon.shape/Arc.outerRadius|{}outerRadius[0]
        final fun <get-outerRadius>(): kotlin/Float // com.juul.krayon.shape/Arc.outerRadius.<get-outerRadius>|<get-outerRadius>(){}[0]
    final var padRadius // com.juul.krayon.shape/Arc.padRadius|{}padRadius[0]
        final fun <get-padRadius>(): kotlin/Function4<com.juul.krayon.shape/Arc, kotlin/Float, kotlin/Float, kotlin/Float, kotlin/Float> // com.juul.krayon.shape/Arc.padRadius.<get-padRadius>|<get-padRadius>(){}[0]

    final fun cornerRadius(kotlin/Float): com.juul.krayon.shape/Arc // com.juul.krayon.shape/Arc.cornerRadius|cornerRadius(kotlin.Float){}[0]
    final fun innerRadius(kotlin/Float): com.juul.krayon.shape/Arc // com.juul.krayon.shape/Arc.innerRadius|innerRadius(kotlin.Float){}[0]
    final fun invoke(com.juul.krayon.shape/Slice<*>): com.juul.krayon.kanvas/Path // com.juul.krayon.shape/Arc.invoke|invoke(com.juul.krayon.shape.Slice<*>){}[0]
    final fun invoke(kotlin/Float, kotlin/Float, kotlin/Float): com.juul.krayon.kanvas/Path // com.juul.krayon.shape/Arc.invoke|invoke(kotlin.Float;kotlin.Float;kotlin.Float){}[0]
    final fun outerRadius(kotlin/Float): com.juul.krayon.shape/Arc // com.juul.krayon.shape/Arc.outerRadius|outerRadius(kotlin.Float){}[0]
    final fun padRadius(kotlin/Function4<com.juul.krayon.shape/Arc, kotlin/Float, kotlin/Float, kotlin/Float, kotlin/Float>): com.juul.krayon.shape/Arc // com.juul.krayon.shape/Arc.padRadius|padRadius(kotlin.Function4<com.juul.krayon.shape.Arc,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float>){}[0]
}

final object com.juul.krayon.shape.curve/Linear : com.juul.krayon.shape.curve/Curve { // com.juul.krayon.shape.curve/Linear|null[0]
    final fun endArea(com.juul.krayon.kanvas/PathBuilder<*>) // com.juul.krayon.shape.curve/Linear.endArea|endArea(com.juul.krayon.kanvas.PathBuilder<*>){}[0]
    final fun endLine(com.juul.krayon.kanvas/PathBuilder<*>) // com.juul.krayon.shape.curve/Linear.endLine|endLine(com.juul.krayon.kanvas.PathBuilder<*>){}[0]
    final fun point(com.juul.krayon.kanvas/PathBuilder<*>, kotlin/Float, kotlin/Float) // com.juul.krayon.shape.curve/Linear.point|point(com.juul.krayon.kanvas.PathBuilder<*>;kotlin.Float;kotlin.Float){}[0]
    final fun startArea(com.juul.krayon.kanvas/PathBuilder<*>) // com.juul.krayon.shape.curve/Linear.startArea|startArea(com.juul.krayon.kanvas.PathBuilder<*>){}[0]
    final fun startLine(com.juul.krayon.kanvas/PathBuilder<*>) // com.juul.krayon.shape.curve/Linear.startLine|startLine(com.juul.krayon.kanvas.PathBuilder<*>){}[0]
}

final fun <#A: kotlin/Any> com.juul.krayon.shape/line(): com.juul.krayon.shape/Line<#A> // com.juul.krayon.shape/line|line(){0ยง<kotlin.Any>}[0]
final fun com.juul.krayon.shape/arc(kotlin/Float, kotlin/Float = ...): com.juul.krayon.shape/Arc // com.juul.krayon.shape/arc|arc(kotlin.Float;kotlin.Float){}[0]
final fun com.juul.krayon.shape/pie(): com.juul.krayon.shape/Pie<kotlin/Float> // com.juul.krayon.shape/pie|pie(){}[0]
